; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",558
.DEFINE "fs_type"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pdrv"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fats"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "wflag"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fsi_flag"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "id"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "n_rootdir"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "csize"
.VALUE 9
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "lfnbuf"
.VALUE 11
.CLASS 8
.TYPE 45
.ENDEF
.DEFINE "cdir"
.VALUE 14
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "n_fatent"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fsize"
.VALUE 22
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "volbase"
.VALUE 26
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fatbase"
.VALUE 30
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dirbase"
.VALUE 34
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "database"
.VALUE 38
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "winsect"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "win"
.VALUE 46
.CLASS 8
.DIM 512
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 40
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",29
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",46
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "dptr"
.VALUE 15
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 23
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir"
.VALUE 27
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "fn"
.VALUE 30
.CLASS 8
.DIM 12
.TYPE 108
.ENDEF
.DEFINE "blk_ofs"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",278
.DEFINE "fsize"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fdate"
.VALUE 4
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "ftime"
.VALUE 6
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "fattrib"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "altname"
.VALUE 9
.CLASS 8
.DIM 13
.TYPE 98
.ENDEF
.DEFINE "fname"
.VALUE 22
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",12
.DEFINE "fmt"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fat"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "align"
.VALUE 2
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "n_root"
.VALUE 5
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "au_size"
.VALUE 8
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME5"
	SEGMENT BSS
_fs:
	DS	558
.DEFINE "fs"
.ALIAS "_fs"
.CLASS 83
.VALUE _fs
.TAG "NONAME0"
.TYPE 8
.ENDEF
;    1	#include <ez80.h>
;    2	#include "src_fatfs\ff.h"
;    3	#include "spi.h"
;    4	#include "defines.h"
;    5	
;    6	#define PAGESIZE	1024
;    7	#define FLASHPAGES	128
;    8	#define FLASHSTART	0x0
;    9	
;   10	#define MOSFILENAME	"MOS.bin"
;   11	#define LOADADDRESS	0x50000
;   12	#define DONE		0x70000
;   13	#define	VALUESTART	0x80000
;   14	
;   15	extern void waitZDI(UINT8 status, UINT24 value); // status: boolean success/failure 
;   16	extern void enableFlashKeyRegister(void);
;   17	extern void lockFlashKeyRegister(void);
;   18	extern void fastmemcpy(UINT24 destination, UINT24 source, UINT24 size);
;   19	extern void reset(void);
;   20	
;   21	FATFS 	fs;
	SEGMENT CODE
;   22	
;   23	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",23,"_main"

.LINE 23

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "head"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -8

.TYPE 44

.ENDEF

.DEFINE "done"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -15

.TYPE 14

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -24

.TYPE 14

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -27

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE5
	LD	SP,HL
;   24		FRESULT	fr;
;   25		FIL	   	fil;
;   26		UINT24  br;	
;   27		void * 	dest;
;   28		UINT24 size;
;   29		
;   30		UINT24	counter,pagemax, lastpagebytes;
;   31		UINT24 addressto,addressfrom;
;   32		UINT8	value;
;   33		UINT24 timer;
;   34		UINT8 head;
;   35		UINT8* ptr;
;   36		UINT8 done;
;   37	
;   38		*((UINT8*)DONE) = 0;
.LINE 38

	XOR	A,A
	LD	(458752),A
;   39		head = 0;
.LINE 39

	LD	(IX+%FFFFFFFB),%0
;   40		done = 0;
;   41		while(1) {	
L_10:
.LINE 41

;   42			ptr = (UINT8*)VALUESTART;	
.LINE 42

	LD	BC,524288
	LD	(IX+%FFFFFFF8),BC
;   43			for(value = 0; value < 2; value++) {
.LINE 43

	LD	(IX+%FFFFFFFC),%0
	JR	L_4
L_2:
;   44				*ptr = value + head;
.LINE 44

	LD	HL,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFC)
	ADD	A,(IX+%FFFFFFFB)
	LD	(HL),A
;   45				ptr++;
.LINE 45

	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
	INC	(IX+%FFFFFFFC)
;   46			}
L_4:
.LINE 46

	LD	A,(IX+%FFFFFFFC)
	CP	A,%2
	JR	C,L_2
;   47			done = 128;
.LINE 47

	LD	(IX+%FFFFFFF7),%80
;   48			*((UINT8*)DONE) = done;
.LINE 48

	LD	A,%80
	LD	(458752),A
;   49			while(done == 128) {
.LINE 49

	JR	L_6
L_7:
;   50				done = *((volatile UINT8*)DONE);
.LINE 50

	LD	A,(458752)
	LD	(IX+%FFFFFFF7),A
;   51			}
L_6:
.LINE 51

	LD	A,(IX+%FFFFFFF7)
	CP	A,%80
	JR	Z,L_7
;   52			head += 0x10;
.LINE 52

	LD	A,(IX+%FFFFFFFB)
	ADD	A,%10
	LD	(IX+%FFFFFFFB),A
	JR	L_10
;   53		}
;   54		while(1);
L_12:
.LINE 54

	JR	L_12
;   55		
;   56		
;   57		
;   58		
;   59		
;   60		
;   61		waitZDI(1,0);
;   62		
;   63		init_spi();
;   64		f_mount(&fs, "", 1);
;   65	
;   66		addressto = FLASHSTART;
;   67		addressfrom = LOADADDRESS;
;   68	
;   69		fr = f_open(&fil, MOSFILENAME, FA_READ);
;   70		if(fr == FR_OK) {
;   71	
;   72			di();
;   73			size = f_size(&fil);
;   74			waitZDI(1, size);
;   75	
;   76			fr = f_read(&fil, (void *)LOADADDRESS, size, &br);
;   77	
;   78			f_close(&fil);
;   79			waitZDI(1, br);
;   80			
;   81			// Wait for user to acknowledge proceed (remote ZDI)
;   82			waitZDI(1, 0);
;   83			
;   84			// Unprotect and erase flash
;   85			enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
;   86			FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
;   87			enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
;   88			FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
;   89	
;   90			// Erase all flash pages
;   91			for(counter = 0; counter < FLASHPAGES; counter++)
L_18:
.LINE 91

;   92			{
;   93				FLASH_PAGE = counter;
.LINE 93

	LD	A,(IX+%FFFFFFFD)
	OUT0	(252),A
;   94				FLASH_PGCTL = 0x02;			// Page erase bit enable, start erase
.LINE 94

	LD	A,%2
	OUT0	(255),A
;   95	
;   96				do
L_16:
.LINE 96

;   97				{
;   98					value = FLASH_PGCTL;
.LINE 98

	IN0	A,(255)
	LD	(IX+%FFFFFFFC),A
;   99				}
;  100				while(value & 0x02);// wait for completion of erase			
.LINE 100

	AND	A,%2
	JR	NZ,L_16
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	BC,128
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_18
;  101			}
;  102			
;  103			// determine number of pages to write
;  104			pagemax = size/PAGESIZE;
;  105			if(size%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 105

	LD	BC,1023
	LD	HL,(IX+%FFFFFFE8)
	CALL	__iand
	LD	(IX+%FFFFFFEB),HL
	CALL	__icmpzero
;  106			{
;  107				pagemax += 1;
;  108				lastpagebytes = size%PAGESIZE;			
;  109			}
;  110			else lastpagebytes = PAGESIZE; // normal last page
.LINE 110

;  111	
;  112			waitZDI(1, pagemax);
.LINE 112

	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_waitZDI
	POP	BC
	POP	BC
;  113	
;  114			// write out each page to flash
;  115			for(counter = 0; counter < pagemax; counter++)
.LINE 115

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_31
L_29:
;  116			{
;  117				if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 117

	LD	IY,(IX+%FFFFFFEE)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_27
;  118					fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 118

	LD	BC,(IX+%FFFFFFE5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  119				else 
.LINE 119

	JR	L_28
L_27:
;  120					fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 120

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_28:
;  121			
;  122				addressto += PAGESIZE;
.LINE 122

	LD	BC,1024
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
;  123				addressfrom += PAGESIZE;
.LINE 123

	LD	HL,(IX+%FFFFFFF1)
	ADD	HL,BC
	LD	(IX+%FFFFFFF1),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  124				//timer = 0;
;  125				//while(timer++ < 32768);
;  126				//waitZDI(FEEDBACK_PAGEWRITTEN, counter);
;  127			}
L_31:
.LINE 127

	LD	BC,(IX+%FFFFFFEE)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_29
;  128			lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 128

	CALL	_lockFlashKeyRegister
;  129			waitZDI(1, counter);
.LINE 129

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_waitZDI
	POP	BC
	POP	BC
;  130		}
;  131		else waitZDI(0, 0);
.LINE 131

;  132		while(1);
L_36:
.LINE 132

	JR	L_36
;  133		return 0;
;  134	}
.LINE 134

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_lockFlashKeyRegister               IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;_waitZDI                            IMPORT  -----   function
;lastpagebytes                        IX-27      3   variable
;size                                 IX-24      3   variable
;G_0                                  IX-21      3   variable
;pagemax                              IX-18      3   variable
;addressfrom                          IX-15      3   variable
;addressto                            IX-12      3   variable
;done                                  IX-9      1   variable
;ptr                                   IX-8      3   variable
;head                                  IX-5      1   variable
;value                                 IX-4      1   variable
;counter                               IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",134,"_main"
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _waitZDI:ROM
	XREF __iand:ROM
	XREF __icmpzero:ROM
	XDEF _main
	XDEF _fs
	END
