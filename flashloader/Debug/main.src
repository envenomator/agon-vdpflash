; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",558
.DEFINE "fs_type"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pdrv"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fats"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "wflag"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fsi_flag"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "id"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "n_rootdir"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "csize"
.VALUE 9
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "lfnbuf"
.VALUE 11
.CLASS 8
.TYPE 45
.ENDEF
.DEFINE "cdir"
.VALUE 14
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "n_fatent"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fsize"
.VALUE 22
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "volbase"
.VALUE 26
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fatbase"
.VALUE 30
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dirbase"
.VALUE 34
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "database"
.VALUE 38
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "winsect"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "win"
.VALUE 46
.CLASS 8
.DIM 512
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 40
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",29
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",46
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "dptr"
.VALUE 15
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 23
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir"
.VALUE 27
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "fn"
.VALUE 30
.CLASS 8
.DIM 12
.TYPE 108
.ENDEF
.DEFINE "blk_ofs"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",278
.DEFINE "fsize"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fdate"
.VALUE 4
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "ftime"
.VALUE 6
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "fattrib"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "altname"
.VALUE 9
.CLASS 8
.DIM 13
.TYPE 98
.ENDEF
.DEFINE "fname"
.VALUE 22
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",12
.DEFINE "fmt"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fat"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "align"
.VALUE 2
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "n_root"
.VALUE 5
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "au_size"
.VALUE 8
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME5"
	SEGMENT BSS
_fs:
	DS	558
.DEFINE "fs"
.ALIAS "_fs"
.CLASS 83
.VALUE _fs
.TAG "NONAME0"
.TYPE 8
.ENDEF
;    1	#include <ez80.h>
;    2	#include "src_fatfs\ff.h"
;    3	#include "spi.h"
;    4	#include "defines.h"
;    5	#include <stdint.h>
;    6	#include "agontimer.h"
;    7	#include "protocol.h"
;    8	
;    9	#define PAGESIZE	1024
;   10	#define BUFFERSIZE	1024
;   11	#define FLASHPAGES	128
;   12	#define FLASHSTART	0x0
;   13	#define BAUDRATE	500000
;   14	
;   15	#define MOSFILENAME	"MOS.bin"
;   16	#define VDPFILENAME "VDP.bin"
;   17	#define LOADADDRESS	0x50000
;   18	
;   19	extern void init_UART0(void);
;   20	
;   21	extern void enableFlashKeyRegister(void);
;   22	extern void lockFlashKeyRegister(void);
;   23	extern void fastmemcpy(UINT24 destination, UINT24 source, UINT24 size);
;   24	extern void reset(void);
;   25	
;   26	FATFS 	fs;
	SEGMENT CODE
;   27	
;   28	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",28,"_main"

.LINE 28

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "br"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -15

.TYPE 14

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

.DEFINE "mossize"

.CLASS 65

.VALUE -21

.TYPE 14

.ENDEF

.DEFINE "frvdp"

.CLASS 65

.VALUE -24

.TYPE 4

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -25

.TYPE 12

.ENDEF

.DEFINE "frmos"

.CLASS 65

.VALUE -28

.TYPE 4

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -31

.TYPE 14

.ENDEF

.DEFINE "checksum"

.CLASS 65

.VALUE -35

.TYPE 15

.ENDEF

.DEFINE "vdpsize"

.CLASS 65

.VALUE -41

.TYPE 14

.ENDEF

.DEFINE "filmos"

.CLASS 65

.VALUE -70

.TAG "NONAME2"

.TYPE 8

.ENDEF

.DEFINE "filvdp"

.CLASS 65

.VALUE -99

.TAG "NONAME2"

.TYPE 8

.ENDEF

.DEFINE "buffer"

.CLASS 65

.VALUE -1123

.DIM 1024

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1124
	ADD	HL,SP
	LD	SP,HL
;   29		FRESULT	frmos,frvdp;
;   30		FIL	   	filmos,filvdp;
;   31		UINT24  br;	
;   32		void * 	dest;
;   33		UINT24  mossize, vdpsize;
;   34		
;   35		UINT24	counter,pagemax, lastpagebytes;
;   36		UINT24 addressto,addressfrom;
;   37		UINT8	value;
;   38		UINT24 timer;
;   39	
;   40		unsigned char buffer[BUFFERSIZE];
;   41		int n;
;   42		uint32_t checksum;
;   43	
;   44	
;   45		init_spi();
.LINE 45

	CALL	_init_spi
;   46		init_UART0();
.LINE 46

	CALL	_init_UART0
;   47	
;   48		f_mount(&fs, "", 1);
.LINE 48

	LD	BC,1
	PUSH	BC
	LD	BC,L__0
	PUSH	BC
	LD	BC,_fs
	PUSH	BC
	CALL	_f_mount
	POP	BC
	POP	BC
	POP	BC
;   49	
;   50		sendStatus('S', 1, 0); // startup complete
.LINE 50

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,83
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   51	
;   52		addressto = FLASHSTART;
.LINE 52

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
;   53		addressfrom = LOADADDRESS;
.LINE 53

	LD	BC,327680
	LD	(IX+%FFFFFFEE),BC
;   54	
;   55		frmos= f_open(&filmos, MOSFILENAME, FA_READ);
.LINE 55

	LD	BC,1
	PUSH	BC
	LD	BC,L__1
	PUSH	BC
	PEA	IX+%FFFFFFBA
	CALL	_f_open
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE4),HL
;   56		if(frmos != FR_OK) {
.LINE 56

	CALL	__icmpzero
	JR	Z,L_3
;   57			sendStatus('F', 0, frmos); // file not read ok
.LINE 57

	LD	BC,(IX+%FFFFFFE4)
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,0
	PUSH	BC
	LD	BC,70
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   58			while(1);
L_1:
.LINE 58

	JR	L_1
;   59		}
L_3:
.LINE 59

;   60		frvdp= f_open(&filvdp, VDPFILENAME, FA_READ);
.LINE 60

	LD	BC,1
	PUSH	BC
	LD	BC,L__3
	PUSH	BC
	PEA	IX+%FFFFFF9D
	CALL	_f_open
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE8),HL
;   61		if(frvdp != FR_OK) {
.LINE 61

	CALL	__icmpzero
	JR	Z,L_7
;   62			sendStatus('V', 0, frvdp); // file not read ok
.LINE 62

	LD	BC,(IX+%FFFFFFE8)
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,0
	PUSH	BC
	LD	BC,86
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   63			while(1);
L_5:
.LINE 63

	JR	L_5
;   64		}
L_7:
.LINE 64

;   65		mossize = f_size(&filmos);
.LINE 65

	LD	BC,(IX+%FFFFFFC5)
	LD	(IX+%FFFFFFEB),BC
;   66		sendStatus('F', 1, mossize); // file read ok
.LINE 66

	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,1
	PUSH	BC
	LD	BC,70
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   67		vdpsize = f_size(&filvdp);
.LINE 67

	LD	BC,(IX+%FFFFFFA8)
	LD	(IX+%FFFFFFD7),BC
;   68		sendStatus('V', 1, vdpsize); // file read ok
.LINE 68

	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,1
	PUSH	BC
	LD	BC,86
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   69	
;   70		frmos= f_read(&filmos, (void *)LOADADDRESS, mossize, &br);
.LINE 70

	PEA	IX+%FFFFFFF7
	LD	BC,(IX+%FFFFFFEB)
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	PEA	IX+%FFFFFFBA
	CALL	_f_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE4),HL
;   71		sendStatus('M', 1, br); // file read into memory
.LINE 71

	LD	BC,(IX+%FFFFFFF7)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,1
	PUSH	BC
	LD	BC,77
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   72	
;   73		f_close(&filmos);
.LINE 73

	PEA	IX+%FFFFFFBA
	CALL	_f_close
	POP	BC
;   74	
;   75		// Wait for user to acknowledge to proceed
;   76		getch();
.LINE 76

	CALL	_getch
;   77		
;   78		// Unprotect and erase flash
;   79		enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
.LINE 79

	CALL	_enableFlashKeyRegister
;   80		FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
.LINE 80

	XOR	A,A
	OUT0	(250),A
;   81		enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
.LINE 81

	CALL	_enableFlashKeyRegister
;   82		FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
.LINE 82

	LD	A,%5F
	OUT0	(249),A
;   83	
;   84		// Mass erase flash
;   85		FLASH_PGCTL = 0x01;	// mass erase bit enable, start erase all pages
.LINE 85

	LD	A,%1
	OUT0	(255),A
;   86		do {
L_8:
.LINE 86

;   87			value = FLASH_PGCTL;
.LINE 87

	IN0	A,(255)
	LD	(IX+%FFFFFFE7),A
;   88		} while(value & 0x01); // wait for completion of erase
.LINE 88

	AND	A,%1
	JR	NZ,L_8
;   89		sendStatus('E', 1, 128);
.LINE 89

	LD	BC,0
	PUSH	BC
	LD	BC,128
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,69
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   90	
;   91		// determine number of pages to write
;   92		pagemax = mossize/PAGESIZE;
.LINE 92

	LD	HL,(IX+%FFFFFFEB)
	LD	A,%A
	CALL	__ishru_b
	LD	(IX+%FFFFFFF4),HL
;   93		if(mossize%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 93

	LD	BC,1023
	LD	HL,(IX+%FFFFFFEB)
	CALL	__iand
	LD	(IX+%FFFFFFDA),HL
	CALL	__icmpzero
	JR	Z,L_12
;   94		{
;   95			pagemax += 1;
.LINE 95

	LD	BC,(IX+%FFFFFFF4)
	INC	BC
	LD	(IX+%FFFFFFF4),BC
;   96			lastpagebytes = mossize%PAGESIZE;			
.LINE 96

	LD	BC,(IX+%FFFFFFDA)
	LD	(IX+%FFFFFFE1),BC
;   97		}
;   98		else lastpagebytes = PAGESIZE; // normal last page
.LINE 98

	JR	L_20
L_12:
	LD	BC,1024
	LD	(IX+%FFFFFFE1),BC
L_20:
;   99	
;  100		// write out each page to flash
;  101		for(counter = 0; counter < pagemax; counter++)
.LINE 101

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_19
L_17:
;  102		{
;  103			if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 103

	LD	IY,(IX+%FFFFFFF4)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_15
;  104				fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 104

	LD	BC,(IX+%FFFFFFE1)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  105			else 
.LINE 105

	JR	L_16
L_15:
;  106				fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 106

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_16:
;  107		
;  108			addressto += PAGESIZE;
.LINE 108

	LD	BC,1024
	LD	HL,(IX+%FFFFFFF1)
	ADD	HL,BC
	LD	(IX+%FFFFFFF1),HL
;  109			addressfrom += PAGESIZE;
.LINE 109

	LD	HL,(IX+%FFFFFFEE)
	ADD	HL,BC
	LD	(IX+%FFFFFFEE),HL
;  110			sendStatus('X', 1, counter+1);
.LINE 110

	XOR	A,A
	LD	E,A
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%1
	CALL	__ladd_b
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,88
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  111		}
L_19:
.LINE 111

	LD	BC,(IX+%FFFFFFF4)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_17
;  112		lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 112

	CALL	_lockFlashKeyRegister
;  113		sendStatus('P', 1, counter); // programming ok
.LINE 113

	LD	BC,(IX+%FFFFFFFD)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,1
	PUSH	BC
	LD	BC,80
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  114	
;  115		getch(); // sync to receiver
.LINE 115

	CALL	_getch
;  116		// Sending VDP update
;  117		checksum = 0;
.LINE 117

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFDD),BC
	LD	(IX+%FFFFFFE0),A
;  118		while(1) {
L_29:
.LINE 118

;  119			frvdp= f_read(&filvdp, (void *)buffer, BUFFERSIZE, &br);
.LINE 119

	PEA	IX+%FFFFFFF7
	LD	BC,1024
	PUSH	BC
	LD	HL,IX
	LD	BC,-1123
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	PEA	IX+%FFFFFF9D
	CALL	_f_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE8),HL
;  120			if(br == 0) break;
.LINE 120

	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	Z,L_30
;  121			for(n = 0; n < br; n++) {
.LINE 121

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_26
L_24:
;  122				putch(buffer[n]);
.LINE 122

	LD	BC,(IX+%FFFFFFFA)
	LD	HL,IX
	LD	DE,-1123
	ADD	HL,DE
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	PUSH	IY
	PUSH	BC
	LD	IY,-1124
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),A
	POP	BC
	POP	IY
	CALL	_putch
	PUSH	IY
	PUSH	BC
	LD	IY,-1124
	LD	BC,IX
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	POP	IY
	POP	BC
;  123				checksum += buffer[n];
.LINE 123

	LD	DE,(IX+%FFFFFFFA)
	LD	HL,IX
	LD	BC,-1123
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	UEXT	HL
	LD	L,(IY)
	LD	E,H
	LD	BC,(IX+%FFFFFFDD)
	LD	A,(IX+%FFFFFFE0)
	CALL	__ladd
	LD	(IX+%FFFFFFDD),HL
	LD	(IX+%FFFFFFE0),E
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  124			}
L_26:
.LINE 124

	LD	BC,(IX+%FFFFFFF7)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_24
	JR	L_29
;  125		}
L_30:
.LINE 125

;  126		sendStatus('W', 1, checksum);
.LINE 126

	LD	C,(IX+%FFFFFFE0)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFDD)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,87
	PUSH	BC
	CALL	_sendStatus
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  127		while(1);
L_32:
.LINE 127

	JR	L_32
;  128		return 0;
;  129	}
.LINE 129

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_putch                              IMPORT  -----   function
;_lockFlashKeyRegister               IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;_enableFlashKeyRegister             IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_f_close                            IMPORT  -----   function
;_f_read                             IMPORT  -----   function
;_f_open                             IMPORT  -----   function
;_sendStatus                         IMPORT  -----   function
;_fs                                 STATIC    558   variable
;_f_mount                            IMPORT  -----   function
;_init_UART0                         IMPORT  -----   function
;_init_spi                           IMPORT  -----   function
;buffer                             IX-1123   1024   variable
;filvdp                               IX-99     29   variable
;filmos                               IX-70     29   variable
;vdpsize                              IX-41      3   variable
;G_0                                  IX-38      3   variable
;checksum                             IX-35      4   variable
;lastpagebytes                        IX-31      3   variable
;frmos                                IX-28      3   variable
;value                                IX-25      1   variable
;frvdp                                IX-24      3   variable
;mossize                              IX-21      3   variable
;addressfrom                          IX-18      3   variable
;addressto                            IX-15      3   variable
;pagemax                              IX-12      3   variable
;br                                    IX-9      3   variable
;n                                     IX-6      3   variable
;counter                               IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 1136 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",129,"_main"
	SEGMENT STRSECT
L__0:
	DB	0
L__1:
	DB	"MOS.bin"
	DB	0
L__3:
	DB	"VDP.bin"
	DB	0
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _enableFlashKeyRegister:ROM
	XREF _init_UART0:ROM
	XREF _getch:ROM
	XREF _putch:ROM
	XREF _sendStatus:ROM
	XREF _init_spi:ROM
	XREF _f_mount:ROM
	XREF _f_read:ROM
	XREF _f_close:ROM
	XREF _f_open:ROM
	XREF __ladd:ROM
	XREF __iand:ROM
	XREF __itol:ROM
	XREF __icmpzero:ROM
	XREF __ladd_b:ROM
	XREF __ishru_b:ROM
	XDEF _main
	XDEF _fs
	END
